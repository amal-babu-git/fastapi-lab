# Hands-On Alembic Practice Guide

## Part 1: Understanding What You Have

### Current Setup Review

Your project now has:

```
fastapi-learn/
├── .env                    # Database credentials
├── database.py             # FastAPI database connection
├── models.py               # SQLAlchemy models
├── main.py                 # FastAPI app
├── alembic.ini             # Alembic configuration
├── migrations/
│   ├── env.py              # Alembic environment (ASYNC)
│   └── versions/
│       └── 2025_09_30_1636-955bb0742a21_initial_migration_create_products_table.py
```

### What's Already Done

✅ Alembic initialized with async support  
✅ Environment variables configured  
✅ Initial migration created and applied  
✅ `products` table exists in database  

Let's verify:

```bash
# Check current migration version
python -m alembic current

# Output should show:
# INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
# INFO  [alembic.runtime.migration] Will assume transactional DDL.
# 955bb0742a21 (head)
```

---

## Part 2: Understanding the Initial Migration

### What Was Created

Let's examine the generated migration file:

```python
# migrations/versions/2025_09_30_1636-955bb0742a21_initial_migration_create_products_table.py

"""initial migration - create products table

Revision ID: 955bb0742a21          # ← Unique ID for this migration
Revises:                           # ← Empty = first migration
Create Date: 2025-09-30 16:36:00
"""

def upgrade() -> None:
    """Upgrade schema."""
    # Creates the products table
    op.create_table('products',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(), nullable=True),
        sa.Column('description', sa.String(), nullable=True),
        sa.Column('price', sa.Float(), nullable=True),
        sa.Column('quantity', sa.Integer(), nullable=True),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_products_id'), 'products', ['id'], unique=False)

def downgrade() -> None:
    """Downgrade schema."""
    # Removes the products table (rollback)
    op.drop_index(op.f('ix_products_id'), table_name='products')
    op.drop_table('products')
```

### What This Migration Did

When you ran `alembic upgrade head`, it executed:

```sql
-- SQL equivalent of upgrade()
CREATE TABLE products (
    id INTEGER NOT NULL,
    name VARCHAR,
    description VARCHAR,
    price FLOAT,
    quantity INTEGER,
    PRIMARY KEY (id)
);

CREATE INDEX ix_products_id ON products (id);

-- Alembic tracking
INSERT INTO alembic_version (version_num) VALUES ('955bb0742a21');
```

---

## Part 3: Your First Real Migration

Let's practice by adding more fields to the Product model.

### Step 1: Modify the Model

Open `models.py` and enhance the Product model:

```python
# models.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime
from datetime import datetime

Base = declarative_base()

class Product(Base):
    __tablename__ = "products"
    
    # Existing fields
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    description = Column(String)
    price = Column(Float)
    quantity = Column(Integer)
    
    # ✅ NEW FIELDS - Add these
    sku = Column(String, unique=True, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    category = Column(String, nullable=True)
```

### Step 2: Generate Migration

```bash
python -m alembic revision --autogenerate -m "add sku, is_active, timestamps, and category to products"
```

**Expected Output:**
```
INFO  [alembic.autogenerate.compare] Detected added column 'products.sku'
INFO  [alembic.autogenerate.compare] Detected added column 'products.is_active'
INFO  [alembic.autogenerate.compare] Detected added column 'products.created_at'
INFO  [alembic.autogenerate.compare] Detected added column 'products.updated_at'
INFO  [alembic.autogenerate.compare] Detected added column 'products.category'
Generating migrations/versions/2025_09_30_XXXX-YYYYYYYY_add_sku_is_active_timestamps_and_category_to_products.py ...  done
```

### Step 3: Review Generated Migration

Open the newly created file in `migrations/versions/`. It should look like:

```python
def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('products', sa.Column('sku', sa.String(), nullable=True))
    op.add_column('products', sa.Column('is_active', sa.Boolean(), nullable=True))
    op.add_column('products', sa.Column('created_at', sa.DateTime(), nullable=True))
    op.add_column('products', sa.Column('updated_at', sa.DateTime(), nullable=True))
    op.add_column('products', sa.Column('category', sa.String(), nullable=True))
    # ### end Alembic commands ###
```

**⚠️ Problem!** All columns are `nullable=True`, but we want some to be NOT NULL.

### Step 4: Fix the Migration

Edit the migration file to handle existing data:

```python
def upgrade() -> None:
    """Add new columns to products table."""
    # Import necessary modules for default values
    from datetime import datetime
    
    # Add columns as nullable first (for existing rows)
    op.add_column('products', sa.Column('sku', sa.String(), nullable=True))
    op.add_column('products', sa.Column('is_active', sa.Boolean(), nullable=True))
    op.add_column('products', sa.Column('created_at', sa.DateTime(), nullable=True))
    op.add_column('products', sa.Column('updated_at', sa.DateTime(), nullable=True))
    op.add_column('products', sa.Column('category', sa.String(), nullable=True))
    
    # Set default values for existing rows
    op.execute("""
        UPDATE products 
        SET 
            sku = 'SKU-' || CAST(id AS VARCHAR),
            is_active = TRUE,
            created_at = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE sku IS NULL
    """)
    
    # Now make columns NOT NULL where needed
    op.alter_column('products', 'sku', nullable=False)
    op.alter_column('products', 'is_active', nullable=False)
    op.alter_column('products', 'created_at', nullable=False)
    op.alter_column('products', 'updated_at', nullable=False)
    
    # Add unique constraint to SKU
    op.create_unique_constraint('uq_products_sku', 'products', ['sku'])


def downgrade() -> None:
    """Remove new columns from products table."""
    op.drop_constraint('uq_products_sku', 'products', type_='unique')
    op.drop_column('products', 'category')
    op.drop_column('products', 'updated_at')
    op.drop_column('products', 'created_at')
    op.drop_column('products', 'is_active')
    op.drop_column('products', 'sku')
```

### Step 5: Apply Migration

```bash
python -m alembic upgrade head
```

**Expected Output:**
```
INFO  [alembic.runtime.migration] Running upgrade 955bb0742a21 -> abc123def456, add sku, is_active, timestamps, and category to products
```

### Step 6: Verify Changes

Connect to your database and check:

```sql
-- Check table structure
\d products

-- Or query the table
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'products';
```

### Step 7: Test in FastAPI

Update your FastAPI endpoint to use the new fields:

```python
# main.py
from pydantic import BaseModel
from datetime import datetime

class ProductCreate(BaseModel):
    name: str
    description: str
    price: float
    quantity: int
    sku: str
    category: str | None = None

class ProductResponse(BaseModel):
    id: int
    name: str
    description: str
    price: float
    quantity: int
    sku: str
    is_active: bool
    created_at: datetime
    updated_at: datetime
    category: str | None

    class Config:
        from_attributes = True

@app.post("/products", response_model=ProductResponse)
async def create_product(
    product: ProductCreate,
    session: AsyncSession = Depends(get_session)
):
    from models import Product
    
    db_product = Product(
        name=product.name,
        description=product.description,
        price=product.price,
        quantity=product.quantity,
        sku=product.sku,
        category=product.category
    )
    
    session.add(db_product)
    await session.commit()
    await session.refresh(db_product)
    
    return db_product
```

---

## Part 4: Practice - Adding a Related Table

Let's add a `Category` table with a relationship to products.

### Step 1: Update Models

```python
# models.py
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class Category(Base):
    """Product category table."""
    __tablename__ = "categories"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationship
    products = relationship("Product", back_populates="category_rel")


class Product(Base):
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    description = Column(String)
    price = Column(Float)
    quantity = Column(Integer)
    sku = Column(String, unique=True, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Foreign key
    category_id = Column(Integer, ForeignKey('categories.id'), nullable=True)
    
    # Relationship
    category_rel = relationship("Category", back_populates="products")
```

### Step 2: Generate Migration

```bash
python -m alembic revision --autogenerate -m "add categories table and foreign key"
```

### Step 3: Review and Apply

```bash
# Review the generated file
# Then apply
python -m alembic upgrade head
```

---

## Part 5: Common Migration Scenarios

### Scenario 1: Renaming a Column

```python
def upgrade() -> None:
    # Rename 'description' to 'product_description'
    op.alter_column('products', 'description', 
                    new_column_name='product_description')

def downgrade() -> None:
    op.alter_column('products', 'product_description', 
                    new_column_name='description')
```

### Scenario 2: Changing Column Type

```python
def upgrade() -> None:
    # Change price from Float to Numeric(10, 2)
    op.alter_column('products', 'price',
                    type_=sa.Numeric(precision=10, scale=2),
                    existing_type=sa.Float())

def downgrade() -> None:
    op.alter_column('products', 'price',
                    type_=sa.Float(),
                    existing_type=sa.Numeric(precision=10, scale=2))
```

### Scenario 3: Adding Constraints

```python
def upgrade() -> None:
    # Add CHECK constraint
    op.create_check_constraint(
        'ck_products_price_positive',
        'products',
        'price > 0'
    )
    
    # Add UNIQUE constraint on multiple columns
    op.create_unique_constraint(
        'uq_products_name_sku',
        'products',
        ['name', 'sku']
    )

def downgrade() -> None:
    op.drop_constraint('uq_products_name_sku', 'products')
    op.drop_constraint('ck_products_price_positive', 'products')
```

### Scenario 4: Adding Indexes

```python
def upgrade() -> None:
    # Single column index
    op.create_index('ix_products_sku', 'products', ['sku'])
    
    # Composite index
    op.create_index('ix_products_category_active', 'products', 
                    ['category_id', 'is_active'])
    
    # Partial index (PostgreSQL specific)
    op.create_index('ix_products_active_only', 'products', ['id'],
                    postgresql_where=sa.text('is_active = TRUE'))

def downgrade() -> None:
    op.drop_index('ix_products_active_only', 'products')
    op.drop_index('ix_products_category_active', 'products')
    op.drop_index('ix_products_sku', 'products')
```

### Scenario 5: Data Migration

```python
def upgrade() -> None:
    # Add new column
    op.add_column('products', sa.Column('discount_percent', sa.Float(), nullable=True))
    
    # Migrate data: calculate discount from existing price
    op.execute("""
        UPDATE products 
        SET discount_percent = 
            CASE 
                WHEN price > 1000 THEN 10.0
                WHEN price > 500 THEN 5.0
                ELSE 0.0
            END
    """)
    
    # Make column NOT NULL
    op.alter_column('products', 'discount_percent', nullable=False)

def downgrade() -> None:
    op.drop_column('products', 'discount_percent')
```

---

## Part 6: Testing Your Migrations

### Test 1: Upgrade and Downgrade

```bash
# Apply migration
python -m alembic upgrade head

# Check database state
# Verify tables, columns exist

# Rollback migration
python -m alembic downgrade -1

# Check database state again
# Verify tables, columns removed

# Re-apply
python -m alembic upgrade head
```

### Test 2: Check Migration History

```bash
# View all migrations
python -m alembic history

# Output:
# 955bb0742a21 -> abc123def456 (head), add sku, is_active, timestamps
# <base> -> 955bb0742a21, initial migration - create products table

# Verbose output
python -m alembic history --verbose
```

### Test 3: Validate with FastAPI

```python
# Start your FastAPI server
# Test endpoints to ensure they work with new schema

# Example: Create product with new fields
POST /products
{
    "name": "Gaming Laptop",
    "description": "High-end gaming laptop",
    "price": 1999.99,
    "quantity": 5,
    "sku": "LAPTOP-001",
    "category": "Electronics"
}
```

---

## Part 7: Troubleshooting Guide

### Problem 1: "Table already exists"

**Cause:** Trying to create a table that already exists.

**Solution:**
```bash
# Check current version
python -m alembic current

# If no version shown, stamp the database at current state
python -m alembic stamp head
```

### Problem 2: "Can't locate revision"

**Cause:** Migration file deleted or `alembic_version` table out of sync.

**Solution:**
```bash
# Check alembic_version table
SELECT * FROM alembic_version;

# If wrong version, stamp to correct one
python -m alembic stamp <correct_revision_id>
```

### Problem 3: Autogenerate creates empty migration

**Cause:** Alembic can't see your models or no changes detected.

**Solution:**
```python
# Check migrations/env.py
from models import Base
target_metadata = Base.metadata  # Must be set!

# Verify models are imported
# Check that models.py has changes
```

### Problem 4: Connection refused

**Cause:** Database not running or wrong credentials.

**Solution:**
```bash
# Check Docker container
docker-compose ps

# Verify .env file
cat .env

# Test connection manually
psql -h localhost -U fastapi_user -d fastapi_db
```

---

## Part 8: Best Practices Checklist

### Before Creating Migration

- [ ] Models are properly defined with `Base`
- [ ] All new columns have appropriate `nullable` setting
- [ ] Foreign keys have proper `ForeignKey()` definition
- [ ] Relationships use `relationship()` correctly
- [ ] Database is running and accessible

### After Generating Migration

- [ ] Review generated migration file
- [ ] Check if nullable settings are correct
- [ ] Add data migration logic if needed
- [ ] Test both upgrade() and downgrade()
- [ ] Verify downgrade() properly reverses upgrade()

### Before Applying to Production

- [ ] Test migration on development database
- [ ] Test migration on staging database
- [ ] Backup production database
- [ ] Review all SQL that will be executed
- [ ] Plan rollback strategy
- [ ] Schedule maintenance window if needed

---

## Part 9: Quick Reference

### Essential Commands

```bash
# Check status
python -m alembic current

# Create migration (auto)
python -m alembic revision --autogenerate -m "description"

# Create migration (manual)
python -m alembic revision -m "description"

# Apply all pending
python -m alembic upgrade head

# Apply specific version
python -m alembic upgrade <revision>

# Rollback one version
python -m alembic downgrade -1

# Rollback to specific
python -m alembic downgrade <revision>

# Rollback all
python -m alembic downgrade base

# Show history
python -m alembic history

# Show SQL without executing
python -m alembic upgrade head --sql
```

### Useful SQL Queries

```sql
-- Check current migration version
SELECT * FROM alembic_version;

-- List all tables
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public';

-- Check table structure
\d products

-- Count rows
SELECT COUNT(*) FROM products;

-- Check indexes
SELECT * FROM pg_indexes WHERE tablename = 'products';
```

---

## Part 10: Next Steps

Now that you understand Alembic, try these exercises:

1. **Add a User table** with email, password, and timestamps
2. **Create a relationship** between User and Product (favorites)
3. **Add a migration** that populates initial data
4. **Practice rollbacks** to ensure they work correctly
5. **Modify column types** and see how Alembic handles it

### Exercise 1: User Table

Try creating this yourself:

```python
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

Steps:
1. Add model to `models.py`
2. Generate migration
3. Review and edit if needed
4. Apply migration
5. Create FastAPI endpoint to register users
6. Test the endpoint

---

## Conclusion

You now have:
- ✅ Working Alembic setup with async support
- ✅ Environment-based configuration
- ✅ Understanding of migration workflow
- ✅ Knowledge of common patterns and troubleshooting
- ✅ Best practices for production use

**Remember:** Alembic is just version control for your database. Think of migrations like Git commits - each one represents a change to your schema that can be applied or rolled back.
